# Chapter 2.Education

- 이번 챕터에서 배우게 될 교훈은 **객체는 작아야 한다** 이다.

### 1. 가능하면 적게 캡슐화 하세요.

- 복잡성은 직접적으로 '유지보수성'에 영향을 미친다.
- 클래스내 객체수를 **4개** 또는 그 이하의 객체를 캡슐화할 것을 권장한다.
- 캡슐화된 상태는 세계 안에서 '**객체의 위치를 지정하는 고유한 식별자**' 이다.
    ````java
    1. 4개 이하로 충분히 Cash 클래스의 객체를 식별할 수 있다.
    2. == 대신, equals() 메서드를 오버라이드해서 객체의 동일성을 체크하자.
    class Cash{
        private Integer digits;
        private Integer cents;
        private String currency;
     }
    ```` 

### 2. 최소한 뭔가는 캡슐화하세요.

- 프로퍼티가 없는 클래스는 객체지향 프로그래밍에서 악명이 높은 정적 메서드와 유사하다.
- 진정한 객체지향 설계에서는 오직 생성자에서만 new 연사자를 허용해야 한다고 가정하자.
- 순수한 OOP에서는 정적메서드가 존재하지 않기 때문에, 객체를 생성하지 않고서는 메서드 호출이 불가하다.
    ````java
    # BAD : 프로퍼티가 없고, 객체를 생성하지 않으면서 기능을 제공한다.
    class Year{
        int read(){
            return System.currentTimeMillis()/ (1000*60*60*24*30*12) - 1970;
        }     
     }
    ````
    ````java
    # GOOD : 프로퍼티를 제공하며, 객체를 생성된 이후에 기능을 제공한다.
    class Year{
        private Number num;
        Year(final Millis mesc){
            this.num = msec.div(
                1000.mul(60).mul(60).mul(24).mul(30).mul(12)
            ).min(1970);
        } 
        int read(){
            return this.num.intValue();
        }     
     }
    ````

### 3. 항상 인터페이스를 사용하세요.

- 객체는 살아있는 유기체이다.
- 객체는 다른 객체와 유기적으로 협동한다.
- 어플리케이션 전체를 유지보수 가능하도록 만들기 위해서는 최선을 다해서 객체를 **분리해야** 한다.
- **객체분리**란 상호작용하는 **다른 객체를 수정하지 않고서도 해당 객체를 수정할 수 있도록 만든다** 는 것을 의미한다.
    ````java
    - 객체가 다른 객체와 의사소통하기 위해 따라야 하는 계약 이며, 다른 객체가 계약을 준수하도록 만든다.
  
    interface Cash{
        Cash multiply(float factor);
    }
  
    class DefaultCash implements Cash{
        private int dollars;      
        DefaultCash(int dlr){
            this.dollars = dlr;
        }
        @Override
        Cash multiply(float factor){
            return new DefaultCash(this.dollars * factor);
        }
    } 
  
    # Employee 객체는, Cash 객체가 변경되거나 또는 구현체가 변경이 되어도 문제가 생기지 않는다. 
    class Employee{
        private Cash salary;
    }
    
    ````

### 4. 메서드 이름을 신중하게 선택하세요
