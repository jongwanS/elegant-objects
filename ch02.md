# Chapter 2.Education

- 이번 챕터에서 배우게 될 교훈은 **객체는 작아야 한다** 이다.

### 1. 가능하면 적게 캡슐화 하세요.

- 복잡성은 직접적으로 '유지보수성'에 영향을 미친다.
- 클래스내 객체수를 **4개** 또는 그 이하의 객체를 캡슐화할 것을 권장한다.
- 캡슐화된 상태는 세계 안에서 '**객체의 위치를 지정하는 고유한 식별자**' 이다.
    ````java
    1. 4개 이하로 충분히 Cash 클래스의 객체를 식별할 수 있다.
    2. == 대신, equals() 메서드를 오버라이드해서 객체의 동일성을 체크하자.
    class Cash{
        private Integer digits;
        private Integer cents;
        private String currency;
     }
    ```` 

### 2. 최소한 뭔가는 캡슐화하세요.

- 프로퍼티가 없는 클래스는 객체지향 프로그래밍에서 악명이 높은 정적 메서드와 유사하다.
- 진정한 객체지향 설계에서는 오직 생성자에서만 new 연사자를 허용해야 한다고 가정하자.
- 순수한 OOP에서는 정적메서드가 존재하지 않기 때문에, 객체를 생성하지 않고서는 메서드 호출이 불가하다.
    ````java
    # BAD : 프로퍼티가 없고, 객체를 생성하지 않으면서 기능을 제공한다.
    class Year{
        int read(){
            return System.currentTimeMillis()/ (1000*60*60*24*30*12) - 1970;
        }     
     }
    ````
    ````java
    # GOOD : 프로퍼티를 제공하며, 객체를 생성된 이후에 기능을 제공한다.
    class Year{
        private Number num;
        Year(final Millis mesc){
            this.num = msec.div(
                1000.mul(60).mul(60).mul(24).mul(30).mul(12)
            ).min(1970);
        } 
        int read(){
            return this.num.intValue();
        }     
     }
    ````

### 3. 항상 인터페이스를 사용하세요.

- 객체는 살아있는 유기체이다.
- 객체는 다른 객체와 유기적으로 협동한다.
- 어플리케이션 전체를 유지보수 가능하도록 만들기 위해서는 최선을 다해서 객체를 **분리해야** 한다.
- **객체분리**란 상호작용하는 **다른 객체를 수정하지 않고서도 해당 객체를 수정할 수 있도록 만든다** 는 것을 의미한다.
    ````java
    - 객체가 다른 객체와 의사소통하기 위해 따라야 하는 계약 이며, 다른 객체가 계약을 준수하도록 만든다.
  
    interface Cash{
        Cash multiply(float factor);
    }
  
    class DefaultCash implements Cash{
        private int dollars;      
        DefaultCash(int dlr){
            this.dollars = dlr;
        }
        @Override
        Cash multiply(float factor){
            return new DefaultCash(this.dollars * factor);
        }
    } 
  
    # Employee 객체는, Cash 객체가 변경되거나 또는 구현체가 변경이 되어도 문제가 생기지 않는다. 
    class Employee{
        private Cash salary;
    }
    
    ````

### 4. 메서드 이름을 신중하게 선택하세요

- 빌더(builder)의 이름은 **명사**, 조정자(manipulator)의 이름은 **동사**로 짓는다.
    - 빌더 : **새로 만들고 새로운 객체를 반환하는 메서드**, **반환타입은 절대 void 가 되지 않도록** 하며, **명사**로 작성.
    - 조정자 : **객체로 추상화한 실세계 엔티티를 수정하는 메서드**, **반환 타입은 void가 되도록** 하며 **동사**로 작성.
- 빌더와 조정자 에서는 뭔가를 조작한 후 반환하거나, 뭔가를 만드는 동시에 조작하는 메서드가 있어서는 안된다.

1) **빌더는 명사다**
    ````java
    int add(int x, int y) // bad : 객체에게 더하라고 요청하지 않는다. 
    int sum(int x, int y) // good : 합을 계산하고, 객체를 반환해 달라고 요청한다.
    ````
2) **조정자는 동사다**
    ````java
    class Pixel {
        void paint(Color color);
    }    
    Pixel center = new Pixel(50,50);
    center.paint(new Color("red")); //'동사'형태로, 그려라 라고 지시를 하며, 반환값은 void 이다.
    ````
3) **빌더와 조정자 혼합하기**
    ````java
   //메서드는 데이터를 쓰는 동시에, 쓰여진 바이트 수를 카운트 한다. (2개 이상의 역할을 한다)
   class Document{ 
     int write(InputStream contents);
   }
   
   //빌더와 조정자를 함께쓴다.OutputPipe 에서 역할이 완벽하게 분리되었다.(write : 쓰기, bytes : 쓰여진 바이트 수) 
   class Document{ 
     OutputPipe output();
   }
   class OutputPipe{ 
     void write(InputStream contents);
     int bytes();
   }
    ````
4) **Boolean 값을 결과로 반환하는 경우**

- 이 메서드들은 빌더에 속하지만, 가독성 측면에서 이름은 명사가 아닌 **형용사**로 짓는다.
  ````java
  boolean empty();
  boolean readable();
  boolean negative();
  ````

### 5. 퍼블릭 상수(Public Constant)를 사용하지 마세요
