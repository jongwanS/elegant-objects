# Chapter 2.Education

- 이번 챕터에서 배우게 될 교훈은 **객체는 작아야 한다** 이다.

### 1. 가능하면 적게 캡슐화 하세요.

- 복잡성은 직접적으로 '유지보수성'에 영향을 미친다.
- 클래스내 객체수를 **4개** 또는 그 이하의 객체를 캡슐화할 것을 권장한다.
- 캡슐화된 상태는 세계 안에서 '**객체의 위치를 지정하는 고유한 식별자**' 이다.
    ````java
    1. 4개 이하로 충분히 Cash 클래스의 객체를 식별할 수 있다.
    2. == 대신, equals() 메서드를 오버라이드해서 객체의 동일성을 체크하자.
    class Cash{
        private Integer digits;
        private Integer cents;
        private String currency;
     }
    ```` 

### 2. 최소한 뭔가는 캡슐화하세요.

- 프로퍼티가 없는 클래스는 객체지향 프로그래밍에서 악명이 높은 정적 메서드와 유사하다.
- 진정한 객체지향 설계에서는 오직 생성자에서만 new 연사자를 허용해야 한다고 가정하자.
- 순수한 OOP에서는 정적메서드가 존재하지 않기 때문에, 객체를 생성하지 않고서는 메서드 호출이 불가하다.
    ````java
    # BAD : 프로퍼티가 없고, 객체를 생성하지 않으면서 기능을 제공한다.
    class Year{
        int read(){
            return System.currentTimeMillis()/ (1000*60*60*24*30*12) - 1970;
        }     
     }
    ````
    ````java
    # GOOD : 프로퍼티를 제공하며, 객체를 생성된 이후에 기능을 제공한다.
    class Year{
        private Number num;
        Year(final Millis mesc){
            this.num = msec.div(
                1000.mul(60).mul(60).mul(24).mul(30).mul(12)
            ).min(1970);
        } 
        int read(){
            return this.num.intValue();
        }     
     }
    ````

### 3. 항상 인터페이스를 사용하세요.

- 객체는 살아있는 유기체이다.
- 객체는 다른 객체와 유기적으로 협동한다.
- 어플리케이션 전체를 유지보수 가능하도록 만들기 위해서는 최선을 다해서 객체를 **분리해야** 한다.
- **객체분리**란 상호작용하는 **다른 객체를 수정하지 않고서도 해당 객체를 수정할 수 있도록 만든다** 는 것을 의미한다.
    ````java
    - 객체가 다른 객체와 의사소통하기 위해 따라야 하는 계약 이며, 다른 객체가 계약을 준수하도록 만든다.
  
    interface Cash{
        Cash multiply(float factor);
    }
  
    class DefaultCash implements Cash{
        private int dollars;      
        DefaultCash(int dlr){
            this.dollars = dlr;
        }
        @Override
        Cash multiply(float factor){
            return new DefaultCash(this.dollars * factor);
        }
    } 
  
    # Employee 객체는, Cash 객체가 변경되거나 또는 구현체가 변경이 되어도 문제가 생기지 않는다. 
    class Employee{
        private Cash salary;
    }
    
    ````

### 4. 메서드 이름을 신중하게 선택하세요

- 빌더(builder)의 이름은 **명사**, 조정자(manipulator)의 이름은 **동사**로 짓는다.
    - 빌더 : **새로 만들고 새로운 객체를 반환하는 메서드**, **반환타입은 절대 void 가 되지 않도록** 하며, **명사**로 작성.
    - 조정자 : **객체로 추상화한 실세계 엔티티를 수정하는 메서드**, **반환 타입은 void가 되도록** 하며 **동사**로 작성.
- 빌더와 조정자 에서는 뭔가를 조작한 후 반환하거나, 뭔가를 만드는 동시에 조작하는 메서드가 있어서는 안된다.

1) **빌더는 명사다**
    ````java
    int add(int x, int y) // bad : 객체에게 더하라고 요청하지 않는다. 
    int sum(int x, int y) // good : 합을 계산하고, 객체를 반환해 달라고 요청한다.
    ````
2) **조정자는 동사다**
    ````java
    class Pixel {
        void paint(Color color);
    }    
    Pixel center = new Pixel(50,50);
    center.paint(new Color("red")); //'동사'형태로, 그려라 라고 지시를 하며, 반환값은 void 이다.
    ````
3) **빌더와 조정자 혼합하기**
    ````java
   //메서드는 데이터를 쓰는 동시에, 쓰여진 바이트 수를 카운트 한다. (2개 이상의 역할을 한다)
   class Document{ 
     int write(InputStream contents);
   }
   
   //빌더와 조정자를 함께쓴다.OutputPipe 에서 역할이 완벽하게 분리되었다.(write : 쓰기, bytes : 쓰여진 바이트 수) 
   class Document{ 
     OutputPipe output();
   }
   class OutputPipe{ 
     void write(InputStream contents);
     int bytes();
   }
    ````
4) **Boolean 값을 결과로 반환하는 경우**

- 이 메서드들은 빌더에 속하지만, 가독성 측면에서 이름은 명사가 아닌 **형용사**로 짓는다.
  ````java
  boolean empty();
  boolean readable();
  boolean negative();
  ````

### 5. 퍼블릭 상수(Public Constant)를 사용하지 마세요

- 상수라고 불리는 public static final 프로퍼티는 객체 사이에 데이터를 공유하기 위해 사용하는 매커니즘
- 객체들은 어떤 것도 공유해서는 안된다. **독립적**이여야 하고 **닫혀** 있어야 한다..
- 즉, 상수를 이용한 공유 메커니즘은 캡슐화와 객체지향적인 사고 전체를 부정하는 일이다.

1) 결합도 증가
    ````java
   Constants, Records, Rows 가 강하게 결합되어 있다.
   Constants.EOL이 변경되면 참조하는 나머지 클래스의 일이 달라진다.
   
    public class Constants{
        public static final String EOL = "\r\n";
    }
    
    class Records {
        void write(Writer out){
            for(Records rec : this.all){
                out.write(rec.toString());
                out.write(Constants.EOL);
            }
        }    
    }
   
    class Rows{
        void print(PrintStream pnt){
            for(Row row : this.fecch()){
                pnt.printf("{%s}",row, Constants.EOL);
            }
        }
    }
    ````
2) 응집도 저하

- 낮은 응집도는 객체가 자신의 문제를 해결하는데 덜 집중한다. (Constants.EOL)
- 퍼블릭 상수마다 계약의 의미를 캠슐화하는 새로운 클래스를 만들어야 유지보수성에 좋다.
- 수백개의 마이크로 클래스를 만드는것이 훨씬 유지보수하기가 좋음
    ````java
    # refactor : 기능을 공유할 수 있도록, 새로운 클래스를 만든다. 
    # 신규 클래스 : EOL 을 출력, 자신의 일을 확실하게 하는 클래스가 생성됌
  
    class EOLString{
        private final String origin;
        EOLString(String src){
            this.origin = src;
        }
        @Override
        String toString(){
            return String.format("%s\r\n", origin);
        }
    }
  
    class Records {
        void write(Writer out){
            for(Records rec : this.all){
                out.write(new EOLString(rec.toString()));
            }
        }    
    }
   
    class Rows{
        void print(PrintStream pnt){
            for(Row row : this.fecch()){
                pnt.printf(
                    new EOLString(String.format("{%s}"),row)
                );
            }
        }
    }
    ````
    ````java
    # EOLString에 대한 결합은 **계약**을 통해 추가된 것이며, 유지보수성을 높인다. 
    예를들어 윈도우일경우, \r\n 을 추가하는 대신 예외를 던지도록 수정할경우 어떻게 할 수 있을까?
    다른 클래스를 수정할 필요 없이 오직, EOLString 클래스만을 수정하여 응집도를 높이고, 결합도를 낮출 수 있습니다.
    class EOLString{
        private final String origin;
        EOLString(String src){
            this.origin = src;
        }
        @Override
        String toString(){
            if(/*Windows의 경우*/){
                throw new IllegalArgumentException("윈도우 이므로 EOL을 사용할 수 없습니다.");
            }
            return String.format("%s\r\n", origin);
        }
    }
    ````
- 예시, HTTP 클라이언트
    ````java
    # BAD : 퍼블릭 상수를 사용하는 예제
    String body = new HttpRequest()
        .method(HttpMethods.POST) //퍼블릭 상수
        .fetch();
  
    # GOOD : post 리터럴의 의미를 기억할 필요 없이, Post 방식으로 요청을 전송하기만 하면 된다.
    String body = new PostRequest(new HttpRequest()).fetch();
    ````

### 6. 불변 객체로 만드세요.
