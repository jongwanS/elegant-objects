# Chapter 1.Birth

### 1. -er로 끝나는 이름을 사용하지 마세요.

- **클래스는** 객체의 **팩토리**이다.
- 클래스가 객체를 **인스턴스화한다** 라고 표한한다.
- Java 언어에서 팩토리 패턴은 new 연산자를 확장한 것처럼 동작한다.
  new 연사자가 실행되기전 부가적인 로직을 더할 수 있다.
    ````java
    class Shapes{
        public Shape make(String name){
            if("circle".equals(name)) return new Circle();
            if("rectangle".equals(name)) return new Rectangle();
            throw new IllegalArgumentException("not exist");
        }
     }
    ````
- 클래스의 이름은 무엇을 하는지(what he does)가 아니라 무엇인지(**what he is**)에 기반해야 한다.
- 객체는 그의 역량(**capability**)으로 특징지어야 한다. 속성이 아니라, 제가 할수 있는 일(**What I can do**)로 설명해야 한다.
- Manager, Controller, Helper .... Converter , Util, Utils 등은 잘못 지어진 이름이다.

### 2. 생성자 하나를 주 생성자로 만드세요.
- 응집도가 높고 견고한 클래스에는 **적은 수의 메서드** 와 상대적으로 **많은 수의 생성자가 존재**한다.
  ````java
  생성자가 많을수록, 클라이언트가 클래스를 유연하게 사용할 수 있다.
  메서드가 많아지면 클래스의 초점이 흐려지고, 단일 책임 원칙(SRP)를 위반한다.
  new Cash(30);
  new Cash("$29.95");
  new Cash(29.95d);
  new Cash(29.95, "USD");
  ````
- 생성자의 주된 작업은 **제공된 인자를 사용해서 캡슐화하고 있는 프로퍼티를 초기화**하는 일이다.
- 초기화 로직을 단 하나의 생성자에만 위치시키고, 부 생성자들이 주 생성자를 호출하도록 만드는것을 권장한다.
  ````java
  # GOOD : 유연함, 생성자에 사용되는 dlr이 음수불가 조건이 추가될때
           주 생성자만 수정하면 된다.
  class Cash{
    private int dollars;
    Cash(float dlr){
        //부 생성자
        this((int) dlr);
    }
    Cash(String dlr){
        //부 생성자
        this(Cash.parse(dlr));
    }
    Cash(int dlr){
        //주 생성자 - 최 하단에 위치시키는것이 추후 찾기에 편하다.
        this.dollars = dlr;
    }
    private static int parse(String str){
        return Integer.valueOf(str);
    } 
  }
  ````
  ````java
  # BAD : 만약 클래스에 들어오는 dlr이 음수가 될 수 없으면 각 생성자마다 로직을 추가해야 한다.
  class Cash{
    private int dollars;
    Cash(float dlr){
        this.dollars = (int)dlr;
    }
    Cash(String dlr){
        this.dollars = Cash.parse(dlr);
    }
    Cash(int dlr){
        this.dollars = dlr;
    }
    private static int parse(String str){
        return Integer.valueOf(str);
    } 
  }
  ````  

### 3. 생성자에 코드를 넣지 마세요
- 